# java运行时数据区
- 方法区
- 虚拟机栈
- 本地方法栈
- 堆
- 程序计数器

## 程序计数器
- 功能：记录当前线程执行到的虚拟机字节码指令地址, 当切换时恢复到正确的位置
- 线程私有
- 若执行在native方法时，计数器为空
- 该内存区域是唯一没有规定OutOfMemory

## 虚拟机栈
- 功能：每个方法执行时会同时创建一个栈帧,栈帧存储局部变量表、操作栈等信息
- 生命周期：每个方法的生灭对应一个栈帧的入栈到出栈
- 局部变量表（就是通常提到的栈）保存了基本数据类型和对象引用， 它所需空间在编译期完成分配
- 该区域可抛出的两种异常:
1 栈深度超出规定throw stackOverflowError
2 当该区域扩展到极限时，throw OutOfMemoryError
- -Xss指定栈大小

## 本地方法栈
- 同虚拟机栈，只是针对native方法

## 堆
- 功能:存放对象实例
- 创建时机：虚拟机创建时创建
- java虚拟机管理的最大一块区域，gc主要对堆管理
- 线程共享
- 堆可连续，可以不连续
- 会throw OutOfMemoryError:Java heap space
- -Xmx -Xms对此区域有效

## 方法区
- 功能：存虚拟机已加载的类信息、常量、静态变量、JIT编译后的代码等
- 多线程共享
- 一般不需要垃圾回收，但也可以做但效果不好
- 该区域无法满嘴内存分配时，throw OutOfMemoryError

### 运行时常量池
  - 功能：存储*编译器生成*的字面量、符号引用、直接引用
  - 除了能存放编译期的常量，具有动态性，比如String类的intern()方法

## 直接内存
- 不是虚拟机运行时数据区的一部分，是直接操作的Native堆
- 会throw OutOfMemoryError

***

## 对象访问
- 问题：对象访问时，在栈上的引用如何堆上的实例、方法区里类信息建立联系？
- 两种方式：
  1.使用句柄：从栈上的本地变量表的地址开始，指向堆上的句柄池找到一个指针对，一个指向堆上的对象实例数据;一个指向方法区中的对象类型数据
  2.使用直接指针：从栈上的本地变量表的地址开始，指向堆上的对象实例数据，再从对象实例数据中的对象类型指针指向方法区中的对象类型数据
  
- 两种方式优缺点：
  1.使用句柄：引用上的地址稳定，不随对象的移动而更新
  2.使用直接指针：速度快，省去一次指向操作的开销
  






