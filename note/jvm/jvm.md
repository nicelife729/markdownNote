# java运行时数据区 （java内存分区）
- 程序计数器（Program Count Register）
- 虚拟机栈 （Stack）
- 本地方法栈 （Program Count Register）
- 堆 （Heap）
- 方法区 （Methon Area）

## 程序计数器
- 功能：记录当前线程执行到的虚拟机字节码指令地址, 当切换时恢复到正确的位置
- 线程私有
- 若执行在native方法时，计数器为空;若线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令
- 该内存区域是唯一没有规定OutOfMemory

## 虚拟机栈
- 功能：每个方法执行时会同时创建一个栈帧,栈帧存储局部变量表、操作栈等信息
- 生命周期：每个方法的生灭对应一个栈帧的入栈到出栈
- 局部变量表（就是通常提到的栈）保存了基本数据类型和对象引用， 它所需空间在编译期完成分配,运行期不会改变
- 该区域可抛出的两种异常:
1 栈深度超出规定throw stackOverflowError
2 当该区域扩展到极限时，throw OutOfMemoryError
- -Xss指定栈大小

## 本地方法栈
- 同虚拟机栈，只是针对native方法

## 方法区(也叫永生代)
- 功能：存虚拟机已加载的类信息、常量、静态变量、JIT编译后的代码等
- 多线程共享
- 一般不需要垃圾回收，但也可以做但效果不好
- 该区域无法满嘴内存分配时，throw OutOfMemoryError PermGen Space
- 存在特殊区域叫常量池
-XX:PermSize –设置Perm区的初始大小
-XX:MaxPermSize –设置Perm区的最大值

### 运行时常量池（Constant Pool）
  - 功能：存储*编译器生成*的字面量、符号引用、直接引用
  - 除了能存放编译期的常量，具有动态性，比如String类的intern()方法
  
## 堆
- 功能:存放对象实例
- 创建时机：虚拟机创建时创建
- java虚拟机管理的最大一块区域，gc主要对堆管理
- 线程共享
- 堆可连续，可以不连续
- 会throw OutOfMemoryError:Java heap space
- -Xmx -Xms对此区域有效
- -XX:+HeapDumpOnOutOfMemoryError 会输出dump堆快照，溢出后可以用工具分析
- -Xms — 设置堆内存初始大小
- -Xmx — 设置堆内存最大值
- -XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数
- -XX:PretenureSizeThreshold — 设置超过指定大小的大对象直接分配在旧生代中

## 直接内存
- 不是虚拟机运行时数据区的一部分，是直接操作的Native堆
- 会throw OutOfMemoryError

***
##执行引擎
负责执行字节码。方法的字节码是由Java虚拟机的指令序列构成的。每一条指令 包含一个单字节的操作码，后面跟随0个或多个操作数。执行引擎执行字节码时，首先取得一个操作码，如果操作码有操作数，取得它的操作数。它执行操作码和跟 随的操作数规定的动作，然后再取得下一个操作码。这个执行字节码的过程在线程完成前将一直持续。


## 对象访问
- 问题：对象访问时，在栈上的引用如何堆上的实例、方法区里类信息建立联系？
- 两种方式：
  1.使用句柄：从栈上的本地变量表的地址开始，指向堆上的句柄池找到一个指针对，一个指向堆上的对象实例数据;一个指向方法区中的对象类型数据
  2.使用直接指针：从栈上的本地变量表的地址开始，指向堆上的对象实例数据，再从对象实例数据中的对象类型指针指向方法区中的对象类型数据
  
- 两种方式优缺点：
  1.使用句柄：引用上的地址稳定，不随对象的移动而更新
  2.使用直接指针：速度快，省去一次指向操作的开销
  
![p3-5](https://github.com/nicelife729/markdownNote/raw/master/note/jvm/image/p3-5.png)

##内存分配

1. 在连续剩余空间中分配内存——指针碰撞

用一个指针指向内存已用区和空闲区的分界点，需要分配新的内存时候，只需要将指针向空闲区移动相应的距离即可。

2. 在不规整的剩余空间中分配内存——空闲列表

如果剩余内存是不规整的，就需要用一个列表记录下哪些内存块是可用的，当需要分配内存的时候就需要在这个列表中查找，找到一个足够大的空间进行分配，然后在更新这个列表。

###分配方式的选择

指针碰撞的分配方式明显要优于空闲列表的方式，但是使用哪种方式取决于堆内存是否规整，而堆内存是否规整则由使用的垃圾收集算法决定。如果堆内存是规整的，则采用指针碰撞的方式分配内存，而如果堆是不规整的，就会采用空闲列表的方式。



## GC回收
思想：分代收集
heap
  - 新生代
    - 初生池
    - 幸存池
      - From Space
      - To Space
  - 老生代

minor GC 触发新生代中初生池被干掉，延长幸存的对象的存在周期，将从初生池过来的放入幸存池中的FromSpace，将超过幸存最大时间的放入老生代中
major GC(Full GC) 触发老生代干掉，挂住所有应用线程

-Xmn — 设置新生代内存大小。
-XX:SurvivorRatio — 设置Eden与Survivor空间的大小比例


###找到需要回收的对象
要对对象进行回收，首先需要找到哪些对象是垃圾，需要回收。有两种方法可以找到需要回收的对象，第一种叫做引用计数法。具体方法就是给对象添加一个引用计数器，计数器的值代表着这个对象被引用的次数，当计数器的值为0的时候，就代表没有引用指向这个对象，那么这个对象就是不可用的，所以就可以对它进行回收。但是有一个问题就是当对象之间循环引用时，其中每个对象的引用计数器的值都不为0，但是这些对象又是作为一个孤立的整体在内存中存在，其他的对象不持有这些对象的引用，这种情况下这些对象就无法被回收，这也是主流的Java虚拟机没有选用这种方法的原因。另一种方法就是把堆中的对象和对象之间的引用分别看作有向图的顶点和有向边。这样只需要从一些顶点开始，对有向图中的每个顶点进行可达性分析（深度优先遍历是有向图可达性算法的基础），这样就可以把不可达的对象找出来，这些不可达的对象还要再进行一次筛选，因为如果对象需要执行finalize()方法，那么它完全可以在finalize()方法中让自己变的可达。这个方法解决了对象之间循环引用的问题。上面提到了“从一些对象开始”进行可达性分析，这些起始对象被称为GC Roots，可以作为GC Roots的对象有：

- 栈区中引用的对象
- 方法区中静态属性或常量引用的对象

上文中提到的引用均是强引用，Java中还存在其他三种引用，分别是，软引用、弱引用和虚引用，当系统即将发生内存溢出时，才会对软引用所引用的对象进行回收；而被弱引用所引用的对象会在下一次触发GC时被回收；虚引用则仅仅是为了在对象被回收时能够收到系统通知。

###垃圾收集算法

1. 标记-清除算法

通过可达性分析算法找到可以回收的对象后，要对这些对象进行标记，代表它可以被回收了。标记完成之后就统一回收所有被标记的对象。这就完成了回收，但是这种方式会产生大量的内存碎片，就导致了可用内存不规整，于是分配新的内存时就需要采用空闲列表的方法，如果没有找到足够大的空间，那么就要提前触发下一次垃圾收集。

2. 标记-整理算法

标记的过程和标记-清除算法一样，但是标记完成之后，让所有存活的对象都向堆内存的一端移动，最后直接清除掉边界以外的内存。这样对内存进行回收之后，内存是规整的，于是可以使用指针碰撞的方式分配新的内存。

3. 复制算法

上面所讲的两种算法都使用了先标记的方式，其实当对象数量很多时，这种算法的效率并不高。于是就产生了这种复制算法。它将可用内存分成两个部分，每次只使用其中的一部分，当其中一块用完时，就将仍然存活的对象复制到另外一块上，再把原来的那一块内存清理掉。这样回收的结果同样能得到规整的剩余空间，但是会浪费一部分内存。根据目前通过概率统计方面的研究，新生代中的对象的回收率能够达到90%以上，因此，便可以将新生代划分为三个部分，分别为Eden、Survivor from、Survivor to，大小比例为8：1：1。每次只使用Eden和其中的一块Survivor，回收时将存活的对象复制到另一块Survivor中，这样就只有10%的内存被浪费，但是如果存活的对象总大小超过了Survivor的大小，那么就把多出的对象放入老年代中。

4. 分代收集算法

把Java堆分成新生代和老年代，新生代使用复制算法，老年代使用标记-清理或标记-整理算法。这样可以根据各个代自己的特点，选用合适的收集算法，提高内存收集的效率。在新生代中长期存活的对象会逐渐向老年代过渡，新生代中的对象每经历一次GC，年龄就增加一岁，当年龄超过一定值时，就会被移动到老年代。

###垃圾收集器

上文讲了JVM垃圾回收的原理和使用的算法，接下来就该讲JVM使用的具体的垃圾回收器了。垃圾回收器在JVM中作为一个守护线程运行，它不能过多的占用系统资源，否则将会极大的影响用户体验。在从GC Roots开始对对象进行可达性分析时，需要STOP THE WORLD，因为如果不这么做，程序一边修改引用，GC收集器一边进行标记，那么标记的结果肯定是有问题的，所以收集器应当采取适当的措施减少这个停顿的时间。

- Serial收集器：新生代使用复制算法，老年代使用标记-整理算法，单线程运行
- Concurrent Mark Sweep(CMS)收集器：它的工作过程为初始标记->并发标记->重新标记->并发清除，初始标记和重新标记阶段都需要Stop The World，但是这两个阶段速度都很快，在耗时最长的并发标记阶段可以和用户线程并行工作。该收集器缺点就是内存回收的结果不是规整的可用空间，但是可以通过开关参数来设置对回收后的内存进行碎片整理。

垃圾收集器还有很多，比如ParNew收集器，最前沿的成果之一Garbage-First收集器等等这里就不一一介绍了，每种收集器都有自己的优点和不足，开发者应该选择适用于当前需求的收集器。
-----
#类加载机制

what:
类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。

首先JVM会找到程序的入口类，一般即拥有public static void main(String[] args)这个类，因为要执行main方法，所以要先要加载这个方法所在的.class文件，然后在后续过程中“按需加载”———加载main方法所在类的class文件时以及执行main方法过程所需要用到其他的class文件。这些class文件会通过JVM的ClassLoader加载到JVM内存并且在JVM的方法区中每一个加载的class文件会对应一个Class对象，这个Class对象实际上是某个class文件在JVM中一种runtime表现，它包含着某个class所有的元数据，并作为方法区这个类各种数据的访问入口。
综上所述，class文件从读取(硬盘文件或者字节流、网络)进入到JVM的内存并创建对应的Class对象的过程称之为“类加载”

3个类加载器
Bootstrap Loader  // 负责加载系统类 (是系统内置类) 
       |     - - ExtClassLoader   // 负责加载扩展类(就是继承类和实现类)
                     |     - - AppClassLoader   // 负责加载应用类(程序员自定义的类)


char:
- 动态加载：不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载
   - 委托模型机制

how：
1.装载:查找和导入class文件;

2.连接:

        (1)检查:检查载入的class文件数据的正确性;

        (2)准备:为类的静态变量分配存储空间;

        (3)解析:将符号引用转换成直接引用(这一步是可选的)

3.初始化:初始化静态变量，静态代码块。

when：这样的过程在程序调用类的静态成员的时候开始执行，所以静态方法main()才会成为一般程序的入口方法。类的构造器也会引发该动作。

eg:
```
ClassLoader loader       = ClassName.class.getClassLoader();
ClassLoader ParentLoader = loader.getParent();
```
WARN: Java在逻辑上并不存在BootstrapKLoader的实体！因为它是用C++编写的，所以打印其内容将会得到null

##Java采用了委托模型机制

Why：三个加载器各自完成自己的工作，但它们是如何协调工作呢？

What： Java采用了委托模型机制

HOW：当类加载器需要加载类的时候，先请示其Parent(即上一层加载器)在其搜索路径载入，如果找不到，才在自己的搜索路径搜索该类。这样的顺序其实就是加载器层次上自顶而下的搜索，因为加载器必须保证基础类的加载。
charA: 1避免类的重复加载 2保证基础类的安全

之所以是这种机制，还有一个安全上的考虑：如果某人将一个恶意的基础类加载到jvm，委托模型机制会搜索其父类加载器，显然是不可能找到的，自然就不会将该类加载进来。

```
ClassLoader loader       = ClassName.class.getClassLoader();
ClassLoader ParentLoader = loader.getParent();
```

#自定义ClassLoader

WHY主要有两个原因:
1.需要加载外部的class。
  JVM提供的默认ClassLoader只能加载指定目录下的.jar和.class,如果我们想加载其他位置的class或者jar时，这些默认的类加载器是加载不到的((如果是文件格式必须配置到classpath))。例如:我们要加载网络上一个class字节流。
2.需要实现class的隔离性。
  
  目前我们常用的web服务器，如tomcat,jetty都实现了自己定义的类加载，这些类加载器主要完成以下三个功能:
  
  - 实现加载web应用指定目录下的jar和class
  - 实现部署在容器中的web应用程序共同使用的类库的共享
  - 实现部署在容器中各个web应用程序自己私有类库的相互隔离
  
HOW如何定义自己的类加载器?
1.继承java.lang.ClassLoader
2.覆写父类的findClass()方法

------------------------------------------
#JVM

what: 
Java虚拟机（JVM）是Java应用的运行环境，从一般意义上来讲，JVM是通过规范来定义的一个虚拟的计算机，被设计用来解释执行从Java源码编译而来的字节码。更通俗地说，JVM是指对这个规范的具体实现。这种实现基于严格的指令集和全面的内存模型。另外，JVM也通常被形容为对软件运行时环境的实现。通常JVM实现主要指的是HotSpot。

JVM规范保证任何的实现都能够以同样的方式解释执行字节码。其实现可以多样化，包括进程、独立的Java操作系统或者直接执行字节码的处理器芯片。我们了解最多的JVM是作为软件实现，运行在流行的操作系统平台上（包括Windows、OS X、Linux和Solaris等）。

JVM的结构允许对一个Java应用进行更细微的控制。这些应用运行在沙箱（Sandbox）环境中。确保在没有恰当的许可时，无法访问到本地文件系统、处理器和网络连接。远程执行时，代码还需要进行证书认证。

除了解释执行Java字节码，大多数的JVM实现还包含一个JIT（just-in-time 即时）编译器，用于为常用的方法生成机器码。机器码使用的是CPU的本地语言，相比字节码有着更快的运行速度。

虽然理解JVM不是开发或运行Java程序的必要条件，但是如果多了解一些JVM知识，那么就有机会避免很多性能上的问题。理解了JVM，实际上这些问题会变得简单明了。

##JVM体系结构

JVM规范定义了一系列子系统以及它们的外部行为。JVM主要有以下子系统：

  - Class Loader 类加载器。 用于读入Java源代码并将类加载到数据区。
  - Execution Engine 执行引擎。 执行来自数据区的指令。

数据区使用的是底层操作系统分配给JVM的内存。

###类加载器（Class Loader）

JVM在下面几种不同的层面使用不同的类加载器：

bootstrap class loader（引导类加载器）：是其他类加载器的父类，它用于加载Java核心库，并且是唯一一个用本地代码编写的类加载器。
extension class loader（扩展类加载器）：是bootstrap class loader加载器的子类，用于加载扩展库。
system class loader（系统类加载器）：是extension class loader加载器的子类，用于加载在classpath中的应用程序的类文件。
user-defined class loader（用户定义的类加载器）：是系统类加载器或其他用户定义的类加载器的子类。

当一个类加载器收到一个加载类的请求，首先它会检查缓存，确认该类是否已经被加载，然后把请求代理给它的父类。如果父类没能成功的加载类，那么子类就会自己去尝试加载该类。子类可检查父类加载器的缓存，但父类不能看到子类所加载的类。之所类加载体系会这样设计，是认为一个子类不应该重复加载已经被父类加载过的类。

###执行引擎（Execution Engine）
执行引擎一个接一个地执行被加载到数据区的字节码。为了保证字节码指令对于机器来说是可读的，执行引擎使用下面两个方法：

解释执行：执行引擎把它遇到的每一条指令解释为机器语言。
即时编译：如果一条指令经常被使用，执行引擎会把它编译为本地代码并存储在缓存中。这样，所有和这个方法相关的代码都会直接执行，从而避免重复解释。
尽管即时编译比解释执行要占用更多的时间，但是对于需要使用成千上万次的方法，只需要处理一次。相比每次都解释执行，以本地代码的方式运行会节约很多执行时间。

JVM规范中并不规定一定要使用即时编译。即时编译也不是用于提高JVM性能的唯一的手段。规范仅仅规定了每条字节码对应的本地代码，至于执行引擎如何实现这一对应过程的，完全由JVM的具体实现来决定。

###运行时数据区
思想：自动管理内存。

Java内存模型建立在自动内存管理的概念之上。当一个对象不再被一个应用所引用，垃圾回收器就会回收它，从而释放相应的内存。
这一点和其他很多需要自行释放内存的语言有很大不同。

JVM从底层操作系统中分配内存，并将它们分为以下几个区域：

- 堆空间（Heap Space）：这是共享的内存区域，用于存储可以被垃圾回收器回收的对象。
- 方法区（Method Area）：这块区域以前被称作“永生代”（permanent generation），用于存储被加载的类。这块区域最近被JVM取消了。现在，被加载的类作为元数据加载到底层操作系统的本地内存区。
- 本地区（Native Area）：这个区域用于存储基本类型的引用和变量。



一个有效的管理内存方法是把对空间划分为不同代，这样垃圾回收器就不用扫描整个堆区。
大多数的对象的生命周期都很段短暂，那些生命周期较长的对象往往直到应用退出才需要被清除。

当一个Java应用创建了一个对象，这个对象是被存储到“初生池”（eden pool）。
一旦初生池存储满了，就会在新生代触发一次minor gc（小范围的垃圾回收）。

####minor gc
how：
首先，垃圾回收器会标记出那些“死对象”（不再被应用所引用的对象），同时延长所有保留对象的生命周期（这个生命周期长度是用数字来描述，代表了期所经历过的垃圾回收的次数）。
然后，垃圾回收器会回收这些死对象，并把剩余的活着的对象移动到“幸存池”（survivor pool），从而清空初生池。

####major gc
当一个对象存活达到一定的周期后，它就会被移动到堆中的老生代：“终身代”（tenured pool）。
最后，当终身代被填满时，就会触发一次full gc或major gc（完全的垃圾回收），以清理终身代。

（译者注：一般我们把初生池和幸存池所在的区域合并成为新生代，把终身代所在的区域成为老生代。对应的，在新生代上产生的gc称为minor gc，在老生代上产生的gc称为full gc。希望这样大家在其他地方看到对应的术语时能更好理解）

当垃圾回收（gc）执行的时候，所有应用线程都要被停止，系统产生一次暂停。minor gc非常频繁，所以被优化的能够快速的回收死对象，是新生代的内存的主要的回收方式。major gc运行起来就相对慢得多，因为要扫描非常多的活着的对象。垃圾回收器本身也有多种实现，有些垃圾回收器在一定情况下能更快的执行major gc。

堆的大小是动态的，只有堆需要扩张的时候才会从内存中分配。当堆被填满时，JVM会重新给堆分配更多的内存，直到达到堆大小的上限，这种重新分配同样会导致应用的短暂停止。
###线程

JVM是运行在一个独立的进程中的，但它可以并发执行多个线程，每个线程都运行自己的方法，这是Java必备的一个部分。以即时消息客户端这样一个应用为例，它至少运行两个线程。一个线程用于等待用户输入，另一个检查服务端是否有新的消息传输。再以服务端应用为例，有时一个请求可能要涉及多个线程并发执行，所以需要多线程来处理请求。

在JVM的进程中，所有的线程共享内存和其他可用的资源。每一个JVM进程在进入点（main方法）处都要启动一个主线程，其他线程都从主线程启动，成为执行过程中的一个独立部分。线程可以再不同的处理器上并行执行，同样也可以共享一个处理器，线程调度器负责处理多个线程共享一个处理器的情况。

很多应用（特别是服务端应用）会处理很多任务，需要并行运行。这些任务中有些是非常重要的，需要实时执行的。而另外一些是后台任务，可以在CPU空闲时执行。任务是在不同的线程中运行的。举例子来说，服务端可能有一些低优先级的线程，它们会根据一些数据来计算统计信息。同时也会启动一些高优先级的进程用于处理传入的数据，响应对这些统计信息的请求。这里可能有很多的源数据，很多来自客户端的数据请求，每个请求都会使服务端短暂的停止后台计算的线程以响应这个请求。所以，你必须监控在运行的线程数目并且保证有足够的CPU时间来执行必要的计算。

（译者注：这一段在原文中是在性能优化的章节，译者认为这可能是作者的不小心，似乎放在线程的章节更合适。）
###性能优化

思想：根据应用的场景不同，调整内存管理策略。

堆上减少gc，栈上减少大小，避免过多线程

回收频率高，配置更大堆-Xmx
若经常重新分配内存，则将初始堆大小与最大对大小设置为相同的

更进一步，若知道那种垃圾回收导致性能问题。则可以调整新老生代的比例
-XX:NewRatio参数来具体指定新生代和老生代的大小比例
-Xmn参数设定初始化和最大新生代大小
-XX:NewSize和-XX:MaxNewSize参数设定初始化和最大新生代大小

每一个线程都有一个栈，设置栈大小
-Xss


----------------
JVM的性能取决于其配置是否与应用的功能相匹配。
尽管垃圾回收器和内存回收进程是自动管理内存的，但是你必须掌管它们的频率。
通常来说，你的应用可使用的内存越多，那么这些会导致应用暂停的内存管理进程需要起作用的就越少。

如果垃圾回收发生的频率比你想的要多很多，那么可以在启动JVM的时候为其配置更大的最大堆大小值。堆被填满的时间越久，就越能降低垃圾回收发生的频率。
最大堆大小值可以在启动JVM的时候，用-Xmx参数来设定。默认的最大堆大小是被设置为可用的操作系统内存的四分之一，或者最小1GB。

如果问题出在经常重新分配内存，那么你可以把初始化堆大小设置为和最大堆大小一样。这就意味着JVM永远不需要为堆重新分配内存。
但这样做就会失去动态堆大小适配的优化，堆的大小从一开始就被固定下来。
配置初始化对大小是在启动JVM，用-Xms来设定。默认初始化堆大小会被设定为操作系统可用的物理内存的六十四分之一，或者设置一个最小值。这个值是根据不同的平台来确定的。

如果你清楚是哪种垃圾回收（minor gc或major gc）导致了性能问题，
可以在不改变整个堆大小的情况下设定新生代和老生代的大小比例。对于需要产生大量临时对象的应用，需要增大新生代的比例（当然，后果是减小了老生代的大小）。对于长生命周期对象较多的应用，则需增大老生代的比例（自然需要减少新生代的大小）。

以下几种方法可以用来设定新生代和老生代的大小：

在启动JVM时，使用-XX:NewRatio参数来具体指定新生代和老生代的大小比例。比如，如果想让老生代的大小是新生代的五倍，则设置参数为-XX:NewRatio=5，默认这个参数设定为2（即老生代占用堆空间的三分之二，新生代占用三分之一）。
在启动JVM时，直接使用-Xmn参数设定初始化和最大新生代大小，那么堆中的剩余大小即是老生代的大小。
在启动JVM时，直接使用-XX:NewSize和-XX:MaxNewSize参数设定初始化和最大新生代大小，那么堆中的剩余大小即是老生代的大小。

每一个线程都有一个栈，用于保存函数调用、返回地址等等，这些栈有着对应的内存分配。如果线程过多，就会导致OutOfMemory错误。即使你有足够的空间的堆来存放对象，你的应用也可能会因为创建一个新的线程而崩溃。这种情况下，需要考虑限制线程中的栈大小的最大值。线程栈大小可以在JVM启动的时候，通过-Xss参数来设置，默认这个值被设定为320KB至1024KB之间，这和平台相关。

###性能监控
当开发或运行一个Java应用的时候，对JVM的性能进行监控是很重要的。配置JVM不是一次配置就万事大吉的，特别是你要应对的是Java服务器应用的情况。你必须持续的检查堆内存和非堆内存的分配和使用情况，线程数的创建情况和内存中加载的类的数据情况等。这些都是核心参数。

使用Anturis控制台，你可以为任何的硬件组件上运行的JVM配置监控（例如，在一台电脑上运行的一个Tomcat网页服务器）。

JVM监控可以使用以下衡量标准：

总内存使用情况（MB）：即JVM使用的总内存。如果JVM使用了所有可用内存，这项指标可以衡量底层操作系统的整体性能。
堆内存使用（MB）：即JVM为运行的Java应用所使用的对象分配的所有内存。不使用的对象通常会被垃圾回收器从堆中移除。所以，如果这个指数增大，表示你的应用没有把不使用的对象移除或者你需要更好的配置垃圾回收器的参数。
非堆内存的使用（MB）：即为方法区和代码缓存分配的所有内存。方法区是用于存储被加载的类的引用，如果这些引用没有被适当的清理，永生代池会在每次应用被重新部署的时候都会增大，导致非堆的内存泄露。这个指标也可能指示了线程创建的泄露。
池内总内存（MB）：即JVM所分配的所有变量内存池的内存和（即除了代码缓存区外的所有内存和）。这个指标能够让你明确你的应用在JVM过载前所能使用的总内存。
线程：即所有有效线程数。举个例子，在Tomcat服务器中每个请求都是一个独立的线程来处理，所以这个衡量指标可以表示当前有多少个请求数，是否影响到了后台低权限的线程的运行。
类：即所有被加载的类的总数。如果你的应用动态的创建很多类，这可能是服务器内存泄露的一个原因。

java -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParallelGC


##
gc回收实战
http://blog.csdn.net/firecoder/article/details/7225654




# 类加载器 #

编写.java源码 -> 编译器编译 -> .class 字节码文件 -> ClassLoader 加载.class文件

类加载器负责将.class文件 加载到内存中, 并为之生成 java.lang.Class 对象
![ClassLoader继承结构图](/img/class_loader.png)

* BootStrap 引导类加载器: 负责加载Java的核心类, 是C语言的代码, 负责加载 `JRE/lib/rt.jar`(所有常用JDK类, 都属于它)
```
// ArrayList 位于rt.jar, 由 BootStrape 加载
ArrayList list = new ArrayList();
println(list.getClass().getClassLoader());  // 是Null, 因为c语言写的, 没有类
// 打印Bootstrap 加载类路径
URL[] urls=sun.misc.Launcher.getBootstrapClassPath().getURLs(); 
for (int i = 0; i < urls.length; i++) { 
	System.out.println(urls[i].toExternalForm()); 
}
```
* ExtClassLoader 扩展类加载器: 加载 `jre/lib/ext/*.jar`

* AppClassLoader (系统)应用类加载器, `ClassLoader.getSystemClassLoader()` 直接获得 系统类加载器

## 细节 ##

> 面试题: 程序运行时, 加载类, 类不在工程代码中, 是否报错?

工程代码中由 AppClassLoader 加载, 还有 BootStrap 和 ExtClassLoader 加载类

> 类加载器顺序和特性?


1. 委托机制: 优先由父类加载器加载,父类加载器找不到类,
子类加载器尝试加载, 如 `NoSuchMethodError`,
可能说明类加载器已经在之前加载了一个另一个类, 而那个类没有这个方法

2. 全盘负责机制: 一个类被加载, 这个类所依赖和引用的类也会被这个类加载器加载

> 自定义类加载器, 不一定是采用委托机制

所有自定义加载器, 必须继承 ClassLoader, 重写`findClass`

> .class 文件字节码, 如何称为Class对象

1. 通过io流, 读取.class文件, 生成byte数组
2. 调用ClassLoader 提供的 `defineClass`, 生成 Class 对象

> 常见错误 `java.lang.ClassCassException`

```
Class c = myClassLoader.findClass("java.activition.MimeType");
MimeType mimeType = (mimeType) c.newInstance();
```
MimeType 遵循委托机制, 由父类加载器加载

c.newInstance() 由子类类加载器加载

**不同类加载器, 加载同一个类, 也会出现不同Class对象**

## Tomcat的类加载器 ##

Jndi: 通过配置, 将一个对象交给tomcat创建和管理, 在程序中目录访问原则,
获取到tomcat中的绑定的对象

Tomcat 类加载器是区别于JVM的加载器的

比传统三个类加载器, 添加 Common 类加载器(Tomcat/lib) 和 WebApp(WEB-INF/classes和lib)类加载器

违背父类委托机制, 优先加载当前工程下类和jar, 再去加载tomcat/lib公共类和jar包, 加载顺序:
* BootStrap classes of yourt JVM
* System class loader classes
* /WEB-INFO/calsses
* /WEB-INFO/lib/*.jar
* $CATALINA_HOME/lib
* $CATALINA_HOME/lib/*.jar